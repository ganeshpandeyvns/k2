# K2 Trading Core Specification

## 1. Overview

This document specifies the trading subsystems that handle order management, execution routing, risk controls, and data correctness for the K2 platform.

**Key Constraint:** K2 is non-custodial. We route orders to exchanges (Crypto.com, Kalshi) but never hold funds. The "source of truth" for balances and fills is always the exchange.

---

## 2. Order Management System (OMS)

### 2.1 Order Lifecycle

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           ORDER LIFECYCLE                                   │
│                                                                             │
│  ┌─────────┐    ┌─────────┐    ┌─────────┐    ┌─────────┐    ┌─────────┐  │
│  │ CREATED │───▶│ PENDING │───▶│SUBMITTED│───▶│  OPEN   │───▶│ FILLED  │  │
│  └─────────┘    └─────────┘    └─────────┘    └─────────┘    └─────────┘  │
│       │              │              │              │              │        │
│       │              │              │              │              │        │
│       │              ▼              ▼              ▼              │        │
│       │        ┌─────────┐    ┌─────────┐    ┌─────────┐         │        │
│       │        │REJECTED │    │REJECTED │    │CANCELLED│         │        │
│       │        │(by risk)│    │(by exch)│    │         │         │        │
│       │        └─────────┘    └─────────┘    └─────────┘         │        │
│       │                                           ▲              │        │
│       │                                           │              │        │
│       │                            ┌──────────────┘              │        │
│       │                            │                             │        │
│       │                       ┌─────────┐                        │        │
│       │                       │ PARTIAL │────────────────────────┘        │
│       │                       │ FILLED  │                                 │
│       │                       └─────────┘                                 │
│       │                                                                    │
│       └───── (validation failure) ─────▶ ┌─────────┐                      │
│                                          │ INVALID │                      │
│                                          └─────────┘                      │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘

STATES:
- CREATED:    Order received, assigned ID
- PENDING:    Passed validation, awaiting risk check
- SUBMITTED:  Sent to exchange, awaiting ACK
- OPEN:       Acknowledged by exchange, working
- PARTIAL:    Partially filled
- FILLED:     Fully executed
- CANCELLED:  Cancelled (by user or system)
- REJECTED:   Rejected (by risk engine or exchange)
- INVALID:    Failed validation (never sent)
```

### 2.2 Order Types Supported

| Order Type | Crypto.com | Kalshi | Description |
|------------|------------|--------|-------------|
| Market | ✅ | ✅ | Execute immediately at best price |
| Limit | ✅ | ✅ | Execute at specified price or better |
| Stop-Loss | ✅ | ❌ | Trigger market order when price crosses |
| Stop-Limit | ✅ | ❌ | Trigger limit order when price crosses |

### 2.3 Idempotency

Every order request includes a client-generated `client_order_id`:

```typescript
interface OrderRequest {
  client_order_id: string;  // UUID generated by client
  instrument: string;       // "BTC-USD" or Kalshi ticker
  side: "buy" | "sell";
  order_type: "market" | "limit";
  quantity: string;         // Decimal as string
  price?: string;           // For limit orders
  time_in_force?: "GTC" | "IOC" | "FOK";
}
```

**Idempotency Rules:**
1. Same `client_order_id` within 24 hours → Return existing order (no duplicate submission)
2. `client_order_id` must be unique per user
3. Store `client_order_id` → `order_id` mapping in Redis (24h TTL)

```typescript
// Idempotency check pseudocode
async function submitOrder(userId: string, request: OrderRequest): Promise<Order> {
  const idempotencyKey = `order:${userId}:${request.client_order_id}`;

  // Check if already processed
  const existingOrderId = await redis.get(idempotencyKey);
  if (existingOrderId) {
    return await getOrder(existingOrderId);  // Return existing
  }

  // Create new order
  const order = await createOrder(userId, request);

  // Store mapping before sending to exchange
  await redis.setex(idempotencyKey, 86400, order.id);

  // Submit to exchange
  await submitToExchange(order);

  return order;
}
```

---

## 3. Risk Engine

### 3.1 Pre-Trade Risk Checks

All orders pass through risk checks before submission to exchange:

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           RISK CHECK PIPELINE                               │
│                                                                             │
│  Order ──▶ [Validation] ──▶ [Balance] ──▶ [Limits] ──▶ [Velocity] ──▶ Submit│
│                │               │             │            │                 │
│                ▼               ▼             ▼            ▼                 │
│            REJECT          REJECT        REJECT       REJECT                │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 3.2 Risk Check Details

#### Check 1: Order Validation

```typescript
interface ValidationCheck {
  // Required fields present
  required_fields: ["instrument", "side", "quantity", "order_type"];

  // Quantity must be positive
  quantity: { min: 0.00000001 };

  // Price must be positive for limit orders
  price: { required_if: "order_type === 'limit'", min: 0.00000001 };

  // Instrument must be tradeable
  instrument: { in: SUPPORTED_INSTRUMENTS };

  // User must have linked the required exchange
  exchange_linked: true;
}
```

#### Check 2: Balance Check

```typescript
interface BalanceCheck {
  // For BUY orders: check quote currency balance
  // For SELL orders: check base currency balance

  // Fetch balance from exchange (cached, refreshed every 30s)
  balance: "quantity * price (for buys) <= available_balance";

  // Include pending orders in calculation
  include_pending_orders: true;
}
```

**Note:** Since we're non-custodial, we fetch balances from the exchange API. Cache for 30 seconds but always do a fresh fetch for orders > $1000.

#### Check 3: Order Limits

```typescript
interface OrderLimits {
  // Maximum single order value
  max_order_notional: {
    crypto: 50000,   // $50K max single order
    event: 10000     // $10K max single event order
  };

  // Maximum position per instrument
  max_position_notional: {
    crypto: 100000,  // $100K max position
    event: 25000     // $25K max event position
  };

  // Fat-finger protection: reject if price > 5% from mid
  fat_finger_threshold: 0.05;
}
```

#### Check 4: Velocity Limits

```typescript
interface VelocityLimits {
  // Orders per minute per user
  orders_per_minute: 30;

  // Notional per hour per user
  notional_per_hour: 100000;  // $100K

  // Notional per day per user
  notional_per_day: 500000;   // $500K
}
```

### 3.3 Risk Check Response

```typescript
interface RiskCheckResult {
  passed: boolean;
  checks: {
    validation: { passed: boolean; reason?: string };
    balance: { passed: boolean; available?: string; required?: string };
    limits: { passed: boolean; limit?: string; current?: string };
    velocity: { passed: boolean; limit?: string; current?: string };
  };
}
```

---

## 4. Execution Router

### 4.1 Exchange Adapter Interface

```typescript
interface ExchangeAdapter {
  // Connection
  connect(): Promise<void>;
  disconnect(): Promise<void>;
  isConnected(): boolean;

  // Orders
  submitOrder(order: InternalOrder): Promise<ExchangeOrderResponse>;
  cancelOrder(exchangeOrderId: string): Promise<ExchangeCancelResponse>;
  getOrder(exchangeOrderId: string): Promise<ExchangeOrder>;
  getOpenOrders(): Promise<ExchangeOrder[]>;

  // Balances
  getBalances(): Promise<ExchangeBalance[]>;

  // Market Data
  subscribeToOrderUpdates(callback: OrderUpdateCallback): void;
  subscribeToPrices(instruments: string[], callback: PriceCallback): void;
}
```

### 4.2 Crypto.com Adapter

**Authentication:**
```typescript
// Crypto.com Exchange API uses API key + secret for signing
interface CryptoComCredentials {
  api_key: string;
  api_secret: string;  // For signing requests
}

// For user's linked account (OAuth flow):
interface CryptoComOAuthTokens {
  access_token: string;
  refresh_token: string;
  expires_at: Date;
}
```

**Order Translation:**
```typescript
// K2 Internal → Crypto.com format
function translateToCryptoCom(order: InternalOrder): CryptoComOrder {
  return {
    instrument_name: order.instrument.replace("-", "_"),  // BTC-USD → BTC_USD
    side: order.side.toUpperCase(),  // buy → BUY
    type: order.order_type.toUpperCase(),  // market → MARKET
    quantity: order.quantity,
    price: order.price,
    client_oid: order.client_order_id,
    time_in_force: order.time_in_force || "GTC"
  };
}
```

**Rate Limits:**
- REST: 100 requests per second
- WebSocket: 150 requests per second
- Implement exponential backoff on 429

### 4.3 Kalshi Adapter

**Authentication:**
```typescript
// Kalshi uses email/password for initial auth, then JWT
interface KalshiCredentials {
  email: string;
  password: string;  // Stored encrypted, used for token refresh
}

interface KalshiSession {
  token: string;
  expires_at: Date;
}
```

**Order Translation:**
```typescript
// K2 Internal → Kalshi format
function translateToKalshi(order: InternalOrder): KalshiOrder {
  return {
    ticker: order.instrument,  // Already in Kalshi format
    action: order.side,  // "buy" or "sell"
    type: order.order_type,
    count: parseInt(order.quantity),  // Kalshi uses integer contracts
    // For event markets: side is "yes" or "no", not "buy" or "sell"
    side: order.metadata?.event_side || "yes",
    yes_price: order.side === "buy" ? parseInt(order.price * 100) : undefined,
    no_price: order.side === "sell" ? parseInt(order.price * 100) : undefined,
  };
}
```

**Event Contract Specifics:**
- Contracts are 0-100 cents ($0.00 - $1.00)
- Quantity is integer (number of contracts)
- Settlement is binary: $1.00 if YES, $0.00 if NO

---

## 5. Market Data Ingestion

### 5.1 WebSocket Connection Management

```typescript
class MarketDataManager {
  private connections: Map<Exchange, WebSocketConnection>;
  private subscriptions: Map<string, Set<Callback>>;

  async connect(exchange: Exchange): Promise<void> {
    const ws = new WebSocket(exchange.wsUrl);

    ws.on('open', () => this.onConnect(exchange));
    ws.on('message', (data) => this.onMessage(exchange, data));
    ws.on('close', () => this.onDisconnect(exchange));
    ws.on('error', (err) => this.onError(exchange, err));

    // Heartbeat every 30 seconds
    setInterval(() => ws.ping(), 30000);

    this.connections.set(exchange, ws);
  }

  // Automatic reconnection with exponential backoff
  private async onDisconnect(exchange: Exchange): Promise<void> {
    const delays = [1000, 2000, 4000, 8000, 16000];
    for (const delay of delays) {
      await sleep(delay);
      try {
        await this.connect(exchange);
        await this.resubscribeAll(exchange);
        return;
      } catch (e) {
        console.error(`Reconnect failed, retrying...`);
      }
    }
    this.emit('connection_failed', exchange);
  }
}
```

### 5.2 Snapshot + Delta Handling

```typescript
interface OrderBookState {
  instrument: string;
  bids: Map<string, string>;  // price → quantity
  asks: Map<string, string>;
  sequence: number;
  lastUpdateTime: Date;
}

class OrderBookManager {
  private books: Map<string, OrderBookState>;

  applySnapshot(instrument: string, snapshot: Snapshot): void {
    this.books.set(instrument, {
      instrument,
      bids: new Map(snapshot.bids),
      asks: new Map(snapshot.asks),
      sequence: snapshot.sequence,
      lastUpdateTime: new Date()
    });
  }

  applyDelta(instrument: string, delta: Delta): void {
    const book = this.books.get(instrument);
    if (!book) {
      // Request fresh snapshot
      this.requestSnapshot(instrument);
      return;
    }

    // Sequence validation
    if (delta.sequence !== book.sequence + 1) {
      console.warn(`Sequence gap: expected ${book.sequence + 1}, got ${delta.sequence}`);
      this.requestSnapshot(instrument);
      return;
    }

    // Apply updates
    for (const [price, qty] of delta.bids) {
      if (qty === "0") {
        book.bids.delete(price);
      } else {
        book.bids.set(price, qty);
      }
    }
    // Same for asks...

    book.sequence = delta.sequence;
    book.lastUpdateTime = new Date();
  }
}
```

### 5.3 Price Throttling

Clients don't need 100 updates per second. Throttle to reasonable rate:

```typescript
class PriceThrottler {
  private lastSent: Map<string, number> = new Map();
  private minInterval = 100;  // 100ms = 10 updates/sec max

  shouldSend(instrument: string): boolean {
    const now = Date.now();
    const last = this.lastSent.get(instrument) || 0;

    if (now - last >= this.minInterval) {
      this.lastSent.set(instrument, now);
      return true;
    }
    return false;
  }
}
```

---

## 6. Reconciliation

### 6.1 Source of Truth

**Critical Principle:** The exchange is ALWAYS the source of truth.

K2 maintains a local mirror for:
- Display purposes
- Latency (avoid fetching every time)
- Audit trail

But we regularly reconcile against the exchange:

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        RECONCILIATION SOURCES                               │
│                                                                             │
│  ┌───────────────────┐                    ┌───────────────────┐            │
│  │    K2 Database    │                    │ Exchange (Source  │            │
│  │    (Mirror)       │     RECONCILE      │    of Truth)      │            │
│  │                   │ ◀─────────────────▶│                   │            │
│  │ • Orders table    │                    │ • Order API       │            │
│  │ • Executions      │                    │ • Trade history   │            │
│  │ • Cached balances │                    │ • Balance API     │            │
│  └───────────────────┘                    └───────────────────┘            │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 6.2 Reconciliation Schedule

| Reconciliation | Frequency | Trigger |
|----------------|-----------|---------|
| Order Status | Real-time | WebSocket updates |
| Order Status (backup) | Every 1 min | Polling for missed updates |
| Trade History | Every 5 min | Full sync |
| Balances | Every 30 sec | Polling |
| Positions | Every 1 min | Polling |
| Daily Full Recon | 1x/day (3 AM) | Cron job |

### 6.3 Discrepancy Handling

```typescript
interface ReconciliationResult {
  matched: number;
  discrepancies: Discrepancy[];
}

interface Discrepancy {
  type: "missing_local" | "missing_remote" | "mismatch";
  order_id?: string;
  local_state?: OrderState;
  remote_state?: OrderState;
  field?: string;  // For mismatches
  local_value?: any;
  remote_value?: any;
}

async function handleDiscrepancy(d: Discrepancy): Promise<void> {
  switch (d.type) {
    case "missing_local":
      // Order exists at exchange but not in K2
      // This shouldn't happen unless created outside K2
      await createOrderRecord(d.remote_state);
      await alertOps("Unexpected remote order", d);
      break;

    case "missing_remote":
      // Order exists in K2 but not at exchange
      // Likely cancelled or filled
      await syncOrderFromExchange(d.order_id);
      break;

    case "mismatch":
      // State differs - exchange wins
      await updateOrderFromExchange(d.order_id, d.remote_state);
      await logDiscrepancy(d);
      break;
  }
}
```

---

## 7. Ledger & P&L Tracking

### 7.1 K2's Role in Ledger

**Important:** K2 does NOT implement a full double-entry ledger since we don't hold funds.

We track:
- Order history (submitted, filled, etc.)
- Execution history (fills)
- P&L calculations (for display)
- Cost basis (for user's tax reporting convenience)

### 7.2 Trade Record Schema

```sql
CREATE TABLE trade_records (
    id              UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id         UUID REFERENCES users(id),
    order_id        UUID REFERENCES orders(id),
    exchange        VARCHAR(50) NOT NULL,

    -- Trade details
    instrument      VARCHAR(50) NOT NULL,
    instrument_type VARCHAR(20) NOT NULL,
    side            VARCHAR(10) NOT NULL,
    quantity        DECIMAL(20, 8) NOT NULL,
    price           DECIMAL(20, 8) NOT NULL,
    notional        DECIMAL(20, 2) NOT NULL,  -- quantity * price

    -- Fees
    fee_amount      DECIMAL(20, 8) NOT NULL,
    fee_currency    VARCHAR(10) NOT NULL,

    -- For P&L
    realized_pnl    DECIMAL(20, 2),  -- Calculated on position close
    cost_basis      DECIMAL(20, 8),  -- Per-unit cost for this trade

    -- Timestamps
    executed_at     TIMESTAMP NOT NULL,  -- From exchange
    created_at      TIMESTAMP DEFAULT NOW()
);
```

### 7.3 Position Tracking

```sql
CREATE TABLE positions (
    id              UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id         UUID REFERENCES users(id),
    exchange        VARCHAR(50) NOT NULL,
    instrument      VARCHAR(50) NOT NULL,
    instrument_type VARCHAR(20) NOT NULL,

    -- Position
    quantity        DECIMAL(20, 8) NOT NULL,  -- Can be negative for short
    avg_cost        DECIMAL(20, 8) NOT NULL,
    cost_basis      DECIMAL(20, 2) NOT NULL,  -- Total cost

    -- For events
    side            VARCHAR(10),  -- 'yes' or 'no' for event contracts

    -- Timestamps
    opened_at       TIMESTAMP NOT NULL,
    updated_at      TIMESTAMP DEFAULT NOW(),

    UNIQUE(user_id, exchange, instrument)
);

-- Update position on each trade
CREATE OR REPLACE FUNCTION update_position() RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO positions (user_id, exchange, instrument, instrument_type,
                          quantity, avg_cost, cost_basis, opened_at)
    VALUES (NEW.user_id, NEW.exchange, NEW.instrument, NEW.instrument_type,
            CASE WHEN NEW.side = 'buy' THEN NEW.quantity ELSE -NEW.quantity END,
            NEW.price, NEW.notional, NEW.executed_at)
    ON CONFLICT (user_id, exchange, instrument)
    DO UPDATE SET
        quantity = positions.quantity +
                   CASE WHEN NEW.side = 'buy' THEN NEW.quantity ELSE -NEW.quantity END,
        avg_cost = CASE
            WHEN NEW.side = 'buy' THEN
                (positions.cost_basis + NEW.notional) /
                (positions.quantity + NEW.quantity)
            ELSE positions.avg_cost
            END,
        cost_basis = CASE
            WHEN NEW.side = 'buy' THEN positions.cost_basis + NEW.notional
            ELSE positions.cost_basis - (NEW.quantity * positions.avg_cost)
            END,
        updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;
```

### 7.4 P&L Calculation

```typescript
interface Position {
  instrument: string;
  quantity: number;
  avgCost: number;
  currentPrice: number;
}

function calculateUnrealizedPnL(position: Position): number {
  return (position.currentPrice - position.avgCost) * position.quantity;
}

function calculateRealizedPnL(trade: Trade, position: Position): number {
  if (trade.side === "sell") {
    // Closing long position
    return (trade.price - position.avgCost) * trade.quantity;
  } else {
    // Covering short position
    return (position.avgCost - trade.price) * trade.quantity;
  }
}

// For event contracts (settlement)
function calculateEventSettlement(
  position: EventPosition,
  outcome: "yes" | "no"
): number {
  if (position.side === outcome) {
    // Won: each contract worth $1
    return position.quantity * 1.00 - position.costBasis;
  } else {
    // Lost: each contract worth $0
    return -position.costBasis;
  }
}
```

---

## 8. Error Handling

### 8.1 Error Categories

| Category | Examples | Handling |
|----------|----------|----------|
| Validation | Invalid instrument, negative quantity | Reject immediately, return error |
| Balance | Insufficient funds | Reject, suggest deposit |
| Exchange Rejection | Exchange-side validation failure | Return exchange error message |
| Network | Timeout, connection lost | Retry with backoff, then fail |
| Rate Limit | 429 from exchange | Queue and retry after cooldown |
| System | Database error, internal exception | Log, alert, return generic error |

### 8.2 Retry Strategy

```typescript
interface RetryConfig {
  maxAttempts: 3;
  baseDelayMs: 1000;
  maxDelayMs: 10000;
  backoffMultiplier: 2;
  retryableErrors: ["ETIMEDOUT", "ECONNRESET", "RATE_LIMITED"];
}

async function withRetry<T>(
  fn: () => Promise<T>,
  config: RetryConfig
): Promise<T> {
  let lastError: Error;
  let delay = config.baseDelayMs;

  for (let attempt = 1; attempt <= config.maxAttempts; attempt++) {
    try {
      return await fn();
    } catch (error) {
      lastError = error;

      if (!isRetryable(error, config)) {
        throw error;
      }

      if (attempt < config.maxAttempts) {
        await sleep(delay);
        delay = Math.min(delay * config.backoffMultiplier, config.maxDelayMs);
      }
    }
  }

  throw lastError;
}
```

### 8.3 Circuit Breaker

```typescript
class CircuitBreaker {
  private failures = 0;
  private lastFailure: Date | null = null;
  private state: "closed" | "open" | "half-open" = "closed";

  private readonly threshold = 5;  // failures before opening
  private readonly resetTimeout = 30000;  // 30 seconds

  async execute<T>(fn: () => Promise<T>): Promise<T> {
    if (this.state === "open") {
      if (Date.now() - this.lastFailure.getTime() > this.resetTimeout) {
        this.state = "half-open";
      } else {
        throw new Error("Circuit breaker is open");
      }
    }

    try {
      const result = await fn();
      this.onSuccess();
      return result;
    } catch (error) {
      this.onFailure();
      throw error;
    }
  }

  private onSuccess(): void {
    this.failures = 0;
    this.state = "closed";
  }

  private onFailure(): void {
    this.failures++;
    this.lastFailure = new Date();
    if (this.failures >= this.threshold) {
      this.state = "open";
    }
  }
}
```

---

## 9. Performance Requirements

### 9.1 Latency Targets

| Operation | Target P50 | Target P95 | Target P99 |
|-----------|------------|------------|------------|
| Order Submit (to exchange) | 50ms | 150ms | 300ms |
| Order Ack (from exchange) | 100ms | 300ms | 500ms |
| Price Update (to client) | 50ms | 100ms | 200ms |
| Balance Fetch | 100ms | 300ms | 500ms |
| Risk Check | 5ms | 20ms | 50ms |

### 9.2 Throughput Targets

| Metric | Target |
|--------|--------|
| Orders per second (per user) | 5 |
| Orders per second (system) | 100 |
| Price updates per second | 1000 |
| Concurrent WebSocket connections | 10,000 |

### 9.3 Availability Targets

| Metric | Target |
|--------|--------|
| System Uptime | 99.9% |
| Trading Availability | 99.5% (depends on exchanges) |
| Data Freshness | <5 seconds stale |

---

## 10. Testing Strategy

### 10.1 Unit Tests

- All risk check logic
- Order translation (K2 → Exchange format)
- P&L calculations
- Sequence handling

### 10.2 Integration Tests

- Exchange adapter (with sandbox APIs)
- Database operations
- Redis caching

### 10.3 Simulation Testing

```typescript
// Trading simulator for testing without exchange
class TradingSimulator implements ExchangeAdapter {
  private orders: Map<string, SimulatedOrder> = new Map();
  private fills: Map<string, SimulatedFill[]> = new Map();

  async submitOrder(order: InternalOrder): Promise<ExchangeOrderResponse> {
    // Simulate latency
    await sleep(randomBetween(10, 50));

    // Simulate fill based on order type
    if (order.orderType === "market") {
      await this.simulateImmediateFill(order);
    } else {
      this.orders.set(order.id, { ...order, status: "open" });
    }

    return { orderId: order.id, status: "accepted" };
  }

  private async simulateImmediateFill(order: InternalOrder): Promise<void> {
    // Simulate realistic fill with slight slippage
    const fillPrice = order.side === "buy"
      ? order.price * (1 + randomBetween(0, 0.001))  // Up to 0.1% slippage
      : order.price * (1 - randomBetween(0, 0.001));

    this.fills.set(order.id, [{
      quantity: order.quantity,
      price: fillPrice,
      timestamp: new Date()
    }]);
  }
}
```

### 10.4 Chaos Testing

- Simulate exchange disconnection
- Simulate high latency
- Simulate partial fills
- Simulate out-of-sequence updates

